<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MONAD DAPPS HUB â€” 3D Hologram Carousel</title>
  <style>
    html,body { height:100%; margin:0; background:#000; overflow:hidden; -webkit-font-smoothing:antialiased; }
    canvas { display:block; position:fixed; inset:0; width:100%; height:100%; touch-action:none; z-index: 0; } /* touch-action:none => kita tangani touch manually */
    #title, #footer {
      position: absolute;
      left: 0; right: 0;
      text-align: center;
      color: #00f0ff;
      text-shadow: 0 0 8px #00f0ff, 0 0 18px #00f0ff;
      font-family: Inter, Arial, sans-serif;
      pointer-events: none;
      z-index: 10;
    }
    #title { top:20px; font-weight:700; font-size:28px; }
    #footer { bottom:18px; font-weight:700; font-size:18px; letter-spacing:1px; }
    /* small screens */
    @media (max-width:600px){
      #title { font-size:20px; }
      #footer { font-size:14px; }
    }
  </style>
</head>
<body>
  <div id="title">MONAD DAPPS</div>
  <div id="footer">PICK YOUR APP</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

  const scene = new THREE.Scene();

// ---------------------------
// Neon Grid Cyberpunk Background
// ---------------------------
const gridSize = 200;   // ukuran grid
const divisions = 100;  // banyak garis
const gridColor = new THREE.Color(0x00ffff); // warna neon cyan

const gridHelper = new THREE.GridHelper(gridSize, divisions, gridColor, gridColor);
gridHelper.material.opacity = 0.25;
gridHelper.material.transparent = true;
gridHelper.rotation.x = Math.PI / 2; // jadi horizontal
scene.add(gridHelper);

// Tambahkan lantai glowing plane
const planeGeo = new THREE.PlaneGeometry(gridSize, gridSize);
const planeMat = new THREE.MeshBasicMaterial({
  color: 0x000000,
  transparent: true,
  opacity: 0.8
});
const plane = new THREE.Mesh(planeGeo, planeMat);
plane.rotation.x = -Math.PI / 2;
scene.add(plane);







  const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 10);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.domElement.style.touchAction = 'none';
  document.body.appendChild(renderer.domElement);

  // lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.25));
  const pLight = new THREE.PointLight(0x00ffff, 1.6, 60);
  pLight.position.set(0, 6, 12);
  scene.add(pLight);



  // ---------------------------
  // App data
  // ---------------------------
const appLinks = [
  { 
    name: "Bridge", 
    url: "https://testnet.monad.xyz/bridge", 
    desc: "Transfer assets seamlessly across chains with ease.",
    colors: ["#ff3366", "#ff9933"],   // merah â†’ oranye
    image: "logotes.png"
  },
  { 
    name: "Swap",   
    url: "https://testnet.monad.xyz/swap", 
    desc: "Exchange your tokens instantly with low fees and high speed.",
    colors: ["#00ff99", "#00ccff"],   // hijau â†’ biru
    image: "logotes.png"
  },
  { 
    name: "DEX",    
    url: "https://testnet.monad.xyz/dex", 
    desc: "Trade on a decentralized exchange with full transparency.",
    colors: ["#ff0080", "#7928ca"],   // pink â†’ ungu
    image: "logotes.png"
  },
  { 
    name: "Wallet", 
    url: "https://testnet.monad.xyz/wallet", 
    desc: "Securely manage and explore your assets in one place.",
    colors: ["#ffaa00", "#ff0066"],   // emas â†’ merah
    image: "logotes.png"
  },
  { 
    name: "NFT Hub",
    url: "https://testnet.monad.xyz/nft", 
    desc: "Discover, collect, and trade NFTs in an immersive marketplace.",
    colors: ["#00ffff", "#0088ff"],   // cyan â†’ biru tua
    image: "logotes.png"
  }
];



  const spacing = 6.5;
  const centerOffset = ((appLinks.length - 1) * spacing) / 2;
  const cards = [];

  // ---------------------------
  // Fungsi buat card UI (CanvasTexture)
  // ---------------------------
// ---------------------------
// Fungsi buat card UI (CanvasTexture) - versi hologram
// ---------------------------
function createAppCard(app, xPos) {
  const width = 600, height = 800;
  const cvs = document.createElement("canvas");
  cvs.width = width;
  cvs.height = height;
  const ctx = cvs.getContext("2d");

  // background solid (tidak transparan lagi)
  ctx.fillStyle = "rgb(20, 20, 20,)"; 
  ctx.roundRect(0, 0, width, height, 30);
  ctx.fill();

  // border gradient glow
  const gradient = ctx.createLinearGradient(0, 0, width, height);
  gradient.addColorStop(0, app.colors[0]);
  gradient.addColorStop(1, app.colors[1]);
  ctx.strokeStyle = gradient;
  ctx.lineWidth = 8;
  ctx.shadowColor = app.colors[0];
  ctx.shadowBlur = 30;
  ctx.roundRect(0, 0, width, height, 30);
  ctx.stroke();

  // gambar utama
const logo = new Image();
logo.src = app.image || "default.png";
logo.onload = () => {
  ctx.save();
  // bikin lingkaran (bulat) di tengah card
  const radius = 120; // ukuran lingkaran
  const centerX = width / 2;
  const centerY = 250; // posisi Y (atur sesuai selera)

  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
  ctx.closePath();
  ctx.clip();

  // gambar logo ke dalam lingkaran
  ctx.drawImage(logo, centerX - radius, centerY - radius, radius * 2, radius * 2);
  ctx.restore();

  // tambahkan border lingkaran glow
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
  ctx.strokeStyle = app.colors[0];
  ctx.lineWidth = 8;
  ctx.shadowColor = app.colors[1];
  ctx.shadowBlur = 20;
  ctx.stroke();

  tex.needsUpdate = true;
};


  // teks waktu
  ctx.fillStyle = app.colors[0];
  ctx.font = "22px Arial";
  ctx.textAlign = "left";
  ctx.fillText("1 week ago", 40, 460);

  // judul
  ctx.fillStyle = "#ffffff";
  ctx.font = "bold 46px Arial";
  ctx.fillText(app.name, 40, 520);

  // deskripsi
  ctx.fillStyle = "rgba(255,255,255,0.8)";
  ctx.font = "26px Arial";
  wrapText(ctx, app.desc, 40, 580, width-80, 34);

  // convert ke texture
  const tex = new THREE.CanvasTexture(cvs);
  const mat = new THREE.MeshBasicMaterial({
    map: tex,
    transparent: false,   // ðŸ”¥ default solid
    opacity: 1.0
  });

  const mesh = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 4.6), mat);
  mesh.position.set(xPos, 0, 0);

  mesh.userData = { url: app.url, material: mat };
  scene.add(mesh);

  return mesh;
}






  // helper buat rounded rect
  function roundRect(ctx, x, y, w, h, r) {
    if (typeof r === 'number') r = [r,r,r,r];
    ctx.beginPath();
    ctx.moveTo(x+r[0], y);
    ctx.lineTo(x+w-r[1], y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r[1]);
    ctx.lineTo(x+w, y+h-r[2]);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r[2], y+h);
    ctx.lineTo(x+r[3], y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r[3]);
    ctx.lineTo(x, y+r[0]);
    ctx.quadraticCurveTo(x, y, x+r[0], y);
    ctx.closePath();
  }

  // helper text wrap
  function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = text.split(" ");
    let line = "";
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + " ";
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line, x, y);
        line = words[n] + " ";
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line, x, y);
  }

  // generate cards
  appLinks.forEach((app, i) => {
    const card = createAppCard(app, i * spacing - centerOffset);
    cards.push(card);
  });

  // ---------------------------
// Particle Aura
// ---------------------------
const auraParticles = [];

cards.forEach((card, i) => {
  const particleGeo = new THREE.BufferGeometry();
  const particleCount = 80; // jumlah partikel aura per card
  const positions = [];

  for (let j = 0; j < particleCount; j++) {
    const angle = Math.random() * Math.PI * 2;
    const radius = 2.2 + Math.random() * 0.3;
    const y = (Math.random() - 0.5) * 2.5;
    positions.push(
      Math.cos(angle) * radius,
      y,
      Math.sin(angle) * radius
    );
  }

  particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

  const particleMat = new THREE.PointsMaterial({
    color: 0x00ffff,
    size: 0.05,
    transparent: true,
    opacity: 0.6,
    depthWrite: false
  });

  const particleSystem = new THREE.Points(particleGeo, particleMat);
  particleSystem.visible = false; // default off
  card.add(particleSystem);       // ikutin posisi card
  auraParticles.push({ card, system: particleSystem });
});


  // ---------------------------
  // Scroll + Snap + Active card
  // ---------------------------
  let scrollTarget = 0;
  let isPointerDown = false;
  let pointerStartX = 0;
  let scrollStart = 0;
  let movedSinceDown = 0;
  let activeCard = null;

  const sensitivity = 0.02;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const minX = -centerOffset - 0.5;
  const maxX = centerOffset + 0.5;

  function setActiveCard(card) {
    activeCard = card;
  }

  function snapToNearestCard() {
    let nearest = null;
    let minDist = Infinity;
    cards.forEach((c) => {
      const dist = Math.abs(c.position.x - scrollTarget);
      if (dist < minDist) {
        minDist = dist;
        nearest = c;
      }
    });
    if (nearest) {
      scrollTarget = nearest.position.x;
      setActiveCard(nearest);
    }
  }

  renderer.domElement.addEventListener('pointerdown', (e) => {
    isPointerDown = true;
    pointerStartX = e.clientX;
    scrollStart = scrollTarget;
    movedSinceDown = 0;
    renderer.domElement.setPointerCapture(e.pointerId);
  });

  renderer.domElement.addEventListener('pointermove', (e) => {
    if (!isPointerDown) return;
    const dx = e.clientX - pointerStartX;
    movedSinceDown += Math.abs(dx);
    scrollTarget = clamp(scrollStart - dx * sensitivity, minX, maxX);
  });

  renderer.domElement.addEventListener('pointerup', (e) => {
    const clickThreshold = 6;
    const dx = e.clientX - pointerStartX;
    isPointerDown = false;
    try { renderer.domElement.releasePointerCapture(e.pointerId); } catch(_) {}
    if (Math.abs(dx) < clickThreshold && Math.abs(movedSinceDown) < clickThreshold) {
      onClickOpen(e.clientX, e.clientY);
    } else {
      snapToNearestCard();
    }
  });

  renderer.domElement.addEventListener('pointercancel', () => { isPointerDown = false; });

  window.addEventListener('wheel', (e) => {
    const delta = (e.deltaX !== 0) ? e.deltaX : e.deltaY;
    scrollTarget = clamp(scrollTarget + delta * 0.02, minX, maxX);
    e.preventDefault();
    clearTimeout(window._snapTimer);
    window._snapTimer = setTimeout(() => snapToNearestCard(), 120);
  }, { passive: false });

  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft')  scrollTarget = clamp(scrollTarget - spacing, minX, maxX);
    if (e.key === 'ArrowRight') scrollTarget = clamp(scrollTarget + spacing, minX, maxX);
    snapToNearestCard();
  });

  // ---------------------------
  // Raycaster
  // ---------------------------
  const raycaster = new THREE.Raycaster();
  const pointerN = new THREE.Vector2();
  function onClickOpen(clientX, clientY) {
    pointerN.x = (clientX / window.innerWidth) * 2 - 1;
    pointerN.y = -(clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(pointerN, camera);
    const intersects = raycaster.intersectObjects(cards, false);
    if (intersects.length > 0) {
      const url = intersects[0].object.userData?.url;
      if (url) window.open(url, "_blank");
    }
  }

  // ---------------------------
  // Animation loop
  // ---------------------------
function animate() {
  requestAnimationFrame(animate);
  camera.position.x += (scrollTarget - camera.position.x) * 0.12;

  const t = Date.now() * 0.002; // waktu animasi

cards.forEach((c, i) => {
  c.position.y = Math.sin(t * 1.2 + i) * 0.1;

  const aura = auraParticles.find(a => a.card === c);

  if (c === activeCard) {
    // card aktif lebih besar + maju
    c.scale.lerp(new THREE.Vector3(1.5, 1.5, 1.5), 0.1);
    c.position.z += (-2 - c.position.z) * 0.1;

    // efek pulse glow transparan
    const pulse = 0.75 + 0.25 * Math.sin(t * 3);
    c.userData.material.transparent = true;   // ðŸ”¥ aktif bisa transparan
    c.userData.material.opacity = pulse;

    // nyalakan particle aura
    if (aura) {
      aura.system.visible = true;
      aura.system.rotation.y += 0.01;
    }
  } else {
    // card normal solid penuh
    c.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
    c.position.z += (0 - c.position.z) * 0.1;
    c.userData.material.transparent = false;  // ðŸ”¥ non-aktif solid
    c.userData.material.opacity = 1.0;

    if (aura) aura.system.visible = false;
  }
});


// animasi grid neon
gridHelper.material.opacity = 0.15 + 0.1 * Math.sin(Date.now() * 0.003);
gridHelper.position.y = -3 + Math.sin(Date.now() * 0.0015) * 0.5;

  renderer.render(scene, camera);
}

  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>


</body>
</html>

