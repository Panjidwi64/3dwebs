<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MONAD DAPPS HUB â€” 3D Hologram Carousel</title>
  <style>
    html,body { height:100%; margin:0; background:#000; overflow:hidden; -webkit-font-smoothing:antialiased; }
    canvas { display:block; position:fixed; inset:0; width:100%; height:100%; touch-action:none; z-index: 0; } /* touch-action:none => kita tangani touch manually */
    #title, #footer {
      position: absolute;
      left: 0; right: 0;
      text-align: center;
      color: #00f0ff;
      text-shadow: 0 0 8px #00f0ff, 0 0 18px #00f0ff;
      font-family: Inter, Arial, sans-serif;
      pointer-events: none;
      z-index: 10;
    }
    #title { top:20px; font-weight:700; font-size:28px; }
    #footer { bottom:18px; font-weight:700; font-size:18px; letter-spacing:1px; }
    /* small screens */
    @media (max-width:600px){
      #title { font-size:20px; }
      #footer { font-size:14px; }
    }
  </style>
</head>
<body>
  <div id="title">MONAD DAPPS</div>
  <div id="footer">PICK YOUR APP</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

const scene = new THREE.Scene();

// background video
const video = document.createElement("video");
video.src = "vid1.mp4";
video.loop = true;
video.muted = true;
video.autoplay = true;
video.playsInline = true;
video.play();
const videoTexture = new THREE.VideoTexture(video);
scene.background = videoTexture;

const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.domElement.style.touchAction = 'none';
document.body.appendChild(renderer.domElement);

// lights
scene.add(new THREE.AmbientLight(0xffffff, 0.25));
const pLight = new THREE.PointLight(0x00ffff, 1.6, 60);
pLight.position.set(0, 6, 12);
scene.add(pLight);

// ------------------
// scroll & pointer state
// ------------------
let scrollTarget = 0;
let isDragging = false;
let dragStartX = 0;
let savedTarget = 0;
let pointerN = { x: 0, y: 0 };

let activeIndex = 0;
let activeCard = null;

// ------------------
// App data
// ------------------
const appLinks = [
  { name: "Bridge", url: "https://testnet.monad.xyz/bridge", desc: "Transfer assets seamlessly across chains with ease." },
  { name: "Swap", url: "https://testnet.monad.xyz/swap", desc: "Exchange your tokens instantly with low fees and high speed." },
  { name: "DEX", url: "https://testnet.monad.xyz/dex", desc: "Trade on a decentralized exchange with full transparency." },
  { name: "Wallet", url: "https://testnet.monad.xyz/wallet", desc: "Securely manage and explore your assets in one place." },
  { name: "NFT Hub", url: "https://testnet.monad.xyz/nft", desc: "Discover, collect, and trade NFTs in an immersive marketplace." }
];

const spacing = 6.5;
const centerOffset = ((appLinks.length - 1) * spacing) / 2;
const cards = [];

// ------------------
// Fungsi buat card 3D Depth
// ------------------
function createAppCard(app, xPos) {
  const group = new THREE.Group();
  group.position.set(xPos, 0, 0);

  const materials = [];

  // background panel
  const bgCanvas = document.createElement("canvas");
  bgCanvas.width = 600; bgCanvas.height = 800;
  const bgCtx = bgCanvas.getContext("2d");
  bgCtx.fillStyle = "rgba(0,0,0,0.75)";
  bgCtx.fillRect(0, 0, 600, 800);
  bgCtx.strokeStyle = "#00ffff";
  bgCtx.lineWidth = 10;
  bgCtx.strokeRect(0, 0, 600, 800);
  const bgTex = new THREE.CanvasTexture(bgCanvas);
  const bgMat = new THREE.MeshBasicMaterial({ map: bgTex, transparent: true });
  const bgMesh = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 4.6), bgMat);
  group.add(bgMesh);
  materials.push(bgMat);

  // logo
  const logoCanvas = document.createElement("canvas");
  logoCanvas.width = 600; logoCanvas.height = 800;
  const logoCtx = logoCanvas.getContext("2d");
  const logoTex = new THREE.CanvasTexture(logoCanvas);
  const logoMat = new THREE.MeshBasicMaterial({ map: logoTex, transparent: true });
  const logoMesh = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 4.6), logoMat);
  logoMesh.position.z = 0.02;
  group.add(logoMesh);
  materials.push(logoMat);
  const logo = new Image();
  logo.src = "logotes.png";
  logo.onload = () => {
    logoCtx.drawImage(logo, 200, 40, 200, 200);
    logoTex.needsUpdate = true;
  };

  // title
  const titleCanvas = document.createElement("canvas");
  titleCanvas.width = 600; titleCanvas.height = 200;
  const tCtx = titleCanvas.getContext("2d");
  tCtx.fillStyle = "#00ffff";
  tCtx.font = "bold 60px Arial";
  tCtx.textAlign = "center";
  tCtx.fillText(app.name, 300, 120);
  const titleTex = new THREE.CanvasTexture(titleCanvas);
  const titleMat = new THREE.MeshBasicMaterial({ map: titleTex, transparent: true });
  const titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 1.2), titleMat);
  titleMesh.position.set(0, -0.2, 0.04);
  group.add(titleMesh);
  materials.push(titleMat);

  // description
  const descCanvas = document.createElement("canvas");
  descCanvas.width = 600; descCanvas.height = 400;
  const dCtx = descCanvas.getContext("2d");
  dCtx.fillStyle = "white";
  dCtx.font = "28px Arial";
  dCtx.textAlign = "center";
  wrapText(dCtx, app.desc, 300, 60, 500, 36);
  const descTex = new THREE.CanvasTexture(descCanvas);
  const descMat = new THREE.MeshBasicMaterial({ map: descTex, transparent: true });
  const descMesh = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 2.0), descMat);
  descMesh.position.set(0, -1.2, 0.06);
  group.add(descMesh);
  materials.push(descMat);

  // button
  const btnCanvas = document.createElement("canvas");
  btnCanvas.width = 600; btnCanvas.height = 200;
  const bCtx = btnCanvas.getContext("2d");
  bCtx.fillStyle = "rgba(0,255,255,0.15)";
  bCtx.fillRect(160, 40, 280, 100);
  bCtx.strokeStyle = "#00ffff";
  bCtx.lineWidth = 6;
  bCtx.strokeRect(160, 40, 280, 100);
  bCtx.fillStyle = "#00ffff";
  bCtx.font = "bold 36px Arial";
  bCtx.textAlign = "center";
  bCtx.fillText("Launch App", 300, 110);
  const btnTex = new THREE.CanvasTexture(btnCanvas);
  const btnMat = new THREE.MeshBasicMaterial({ map: btnTex, transparent: true });
  const btnMesh = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 0.8), btnMat);
  btnMesh.position.set(0, -2.0, 0.08);
  group.add(btnMesh);
  materials.push(btnMat);

  group.userData = { url: app.url, materials: materials };
  scene.add(group);
  return group;
}

// helper wrap text
function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
  const words = text.split(" ");
  let line = "";
  for (let n = 0; n < words.length; n++) {
    const testLine = line + words[n] + " ";
    const metrics = ctx.measureText(testLine);
    if (metrics.width > maxWidth && n > 0) {
      ctx.fillText(line, x, y);
      line = words[n] + " ";
      y += lineHeight;
    } else line = testLine;
  }
  ctx.fillText(line, x, y);
}

// generate cards
appLinks.forEach((app, i) => {
  const card = createAppCard(app, i * spacing - centerOffset);
  cards.push(card);
});
activeIndex = 0;
activeCard = cards[0];

// ------------------
// Scroll & snap helpers
// ------------------
function pickActiveFromTarget() {
  let closestIdx = 0, closestDist = Infinity;
  cards.forEach((c, i) => {
    const cardX = i * spacing - centerOffset;
    const d = Math.abs(cardX - scrollTarget);
    if (d < closestDist) { closestDist = d; closestIdx = i; }
  });
  activeIndex = closestIdx;
  activeCard = cards[closestIdx];
}
function clampTarget() {
  const min = -(centerOffset);
  const max = (appLinks.length - 1) * spacing - centerOffset;
  if (scrollTarget < min) scrollTarget = min;
  if (scrollTarget > max) scrollTarget = max;
}
function snapToNearest() {
  scrollTarget = Math.round(scrollTarget / spacing) * spacing;
  clampTarget();
  pickActiveFromTarget();
}

// input events
window.addEventListener('wheel', (e) => {
  const dir = e.deltaY > 0 ? 1 : -1;
  scrollTarget += dir * spacing;
  clampTarget();
  pickActiveFromTarget();
});
renderer.domElement.addEventListener('pointerdown', (e) => {
  isDragging = true; dragStartX = e.clientX; savedTarget = scrollTarget;
});
window.addEventListener('pointermove', (e) => {
  pointerN.x = (e.clientX / window.innerWidth) * 2 - 1;
  pointerN.y = (e.clientY / window.innerHeight) * 2 - 1;
  if (!isDragging) return;
  const dx = e.clientX - dragStartX;
  scrollTarget = savedTarget - dx * 0.02;
  clampTarget();
  pickActiveFromTarget();
});
window.addEventListener('pointerup', () => { isDragging = false; snapToNearest(); });
window.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowRight') scrollTarget += spacing;
  else if (e.key === 'ArrowLeft') scrollTarget -= spacing;
  else return;
  clampTarget();
  snapToNearest();
});

// ------------------
// Animate
// ------------------
function animate() {
  requestAnimationFrame(animate);
  camera.position.x += (scrollTarget - camera.position.x) * 0.12;

  const t = Date.now() * 0.002;

  cards.forEach((c, i) => {
    c.position.y = Math.sin(t * 1.2 + i) * 0.1;
    // parallax kecil
    c.rotation.y = pointerN.x * 0.06;
    c.rotation.x = -pointerN.y * 0.04;

    const aura = (typeof auraParticles !== 'undefined' && auraParticles)
      ? auraParticles.find(a => a.card === c)
      : null;

    if (c === activeCard) {
      c.scale.lerp(new THREE.Vector3(1.5, 1.5, 1.5), 0.1);
      c.position.z += (-2 - c.position.z) * 0.1;
      const pulse = 0.75 + 0.25 * Math.sin(t * 3);
      if (c.userData.materials) c.userData.materials.forEach(m => m.opacity = pulse);
      if (aura) { aura.system.visible = true; aura.system.rotation.y += 0.01; }
    } else {
      c.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
      c.position.z += (0 - c.position.z) * 0.1;
      if (c.userData.materials) c.userData.materials.forEach(m => m.opacity = 0.9);
      if (aura) aura.system.visible = false;
    }
  });

  renderer.render(scene, camera);
}
animate();




  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>


</body>
</html>
